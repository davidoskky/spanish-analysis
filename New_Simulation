import pandas as pd
import numpy as np

from dta_handling import df_eff
from eff_typology import assign_typology

np.random.seed(42)
EPSILON = 1e-6

# --- STEP 0: Assign typology ---
df_eff = assign_typology(df_eff)

# --- STEP 1: Compute wealth rank and assign behavioral erosion ---
df_eff['wealth_rank'] = df_eff['riquezanet'].rank(pct=True)
percriq_map = {
    "< P25": 1,
    "P25-P50": 2,
    "P50-P75": 3,
    "P75-P90": 4,
    "> P90": 5
}
df_eff['percriq'] = df_eff['percriq'].map(percriq_map)
df_eff['percriq'] = pd.to_numeric(df_eff['percriq'], errors='coerce').fillna(0).astype(int)



# Behavioral erosion by wealth percentile group (percriq) and exact rank
def assign_behavioral_erosion(row):
    group = row.get("percriq", 0)
    rank = row.get("wealth_rank", 0)

    if group <= 2:
        return 0.00
    elif group == 3:
        return 0.04
    elif group == 4:
        return 0.075
    elif group == 5:
        if rank > 0.999:
            return 0.18
        elif rank > 0.99:
            return 0.12
        else:
            return 0.08
    return 0.00

df_eff['behavioral_erosion'] = df_eff.apply(assign_behavioral_erosion, axis=1)

def apply_individual_split(df):
    df = df.copy()

    # Use total household size for wealth split
    df["split_factor"] = pd.to_numeric(df["np1"], errors="coerce").clip(lower=1)

    # For income-specific split, fallback if no earners
    if "nnumadtrab" in df.columns:
        earners = pd.to_numeric(df["nnumadtrab"], errors="coerce")
        earners = earners.clip(lower=1).fillna(df["split_factor"])
        df["income_split_factor"] = earners
    else:
        df["income_split_factor"] = df["split_factor"]

    # Apply splits
    df["riquezanet_individual"] = df["riquezanet"] / df["split_factor"]
    df["renthog21_individual"] = df["renthog21_eur22"] / df["income_split_factor"]

    return df

# Apply individual split for households with multiple members
df_eff = apply_individual_split(df_eff)
print(df_eff[['np1', 'nnumadtrab', 'split_factor', 'income_split_factor']].drop_duplicates())

# --- STEP 1B: Compute legal exemptions ---
def compute_legal_exemptions(df):
    split = df["split_factor"]

    # --- Primary residence exemption (if owned) ---
    is_home_exempt = df["np2_1"] == "Ownership"
    home_exempt = np.where(is_home_exempt, df["p2_70"].fillna(0), 0) / split
# Probabilistic business exemption (~30%, value taken from Duran-Cabré et al. 2023)
    business_exemption_rate = 0.30
    apply_business_exempt = np.random.rand(len(df)) < business_exemption_rate
    business_exempt = np.where(apply_business_exempt, df["p2_69"].fillna(0), 0) / split

    return home_exempt + business_exempt
    
# --- STEP 1C: Apply income cap ---
def apply_income_cap(df, income_cap_rate=0.60, min_wt_share=0.20):
    df = df.copy()

    cap_threshold = df["renthog21_individual"] * income_cap_rate
    wt = df["sim_tax"]

    df["cap_applicable"] = wt > cap_threshold  # Flag

    excess = wt - cap_threshold
    max_relief = wt * (1 - min_wt_share)
    relief = np.where(df["cap_applicable"], np.minimum(excess, max_relief), 0.0)

    df["cap_relief"] = relief
    df["final_tax"] = wt - relief

    return df


# --- STEP 2: Wealth tax simulation ---
def simulate_wealth_tax(df, exemption=700_000, income_cap_rate=0.6):
    df = df.copy()

    # --- Correct Brackets ---
    brackets = [
        (0, 167129.45, 0.002),
        (167129.46, 334246.88, 0.003),
        (334246.89, 668499.75, 0.005),
        (668499.76, 1336999.51, 0.009),
        (1336999.52, 2673999.01, 0.013),
        (2673999.02, 5347998.03, 0.017),
        (5347998.04, 10695996.06, 0.021),
        (10695996.07, float('inf'), 0.025),
    ]

    def compute_tax(taxable):
        tax = 0
        for lower, upper, rate in brackets:
            if taxable > lower:
                taxed_amount = min(taxable, upper) - lower
                tax += taxed_amount * rate
            else:
                break
        return tax

    # --- Exemptions (handled externally) ---
    df["exempt_total"] = compute_legal_exemptions(df)

    # --- Non-taxable components (excluded by design) ---
    non_taxable_assets = (
        df["p2_71"].fillna(0) +       # pension
        df["timpvehic"].fillna(0)    # vehicles
    ) / df["split_factor"]

    # --- Adjusted Base (individual) ---
    base = df["riquezanet_individual"] - non_taxable_assets - df["exempt_total"]
    df["taxable_wealth"] = np.maximum(base - exemption, 0)
    df["taxable_wealth_eroded"] = df["taxable_wealth"] * (1 - df["behavioral_erosion"])
    df["sim_tax"] = df["taxable_wealth_eroded"].apply(compute_tax)


    return df

df_eff = simulate_wealth_tax(df_eff)
df_eff = apply_income_cap(df_eff)

# --- STEP 6: Migration attrition module ---
MIGRATION_THRESHOLDS = {
    "top_01": 0.999,
    "top_1": 0.99,
    "top_5": 0.95,
}
BASE_PROBABILITIES = {
    "top_01": 0.08,
    "top_1": 0.03,
    "top_5": 0.009,
}

def compute_migration_probability(row):
    p = row.get("wealth_rank", 0)
    prob = 0.0
    if p > MIGRATION_THRESHOLDS["top_01"]:
        prob = BASE_PROBABILITIES["top_01"]
    elif p > MIGRATION_THRESHOLDS["top_1"]:
        prob = BASE_PROBABILITIES["top_1"]
    elif p > MIGRATION_THRESHOLDS["top_5"]:
        prob = BASE_PROBABILITIES["top_5"]

    ratio = row.get("sim_tax", 0) / (row.get("taxable_wealth_eroded", 0) + 1e-6)
    prob *= 1 + 2 * min(ratio, 0.02)

    return min(prob, 1.0)

def apply_migration_module(df):
    df = df.copy()
    df["Migration_Prob"] = df.apply(compute_migration_probability, axis=1)
    df["Migration_Exit"] = np.random.rand(len(df)) < df["Migration_Prob"]

    df.loc[df["Migration_Exit"], ["taxable_wealth_eroded", "sim_tax", "final_tax", "cap_relief"]] = 0.0

    print(f" Migration module applied: {df['Migration_Exit'].sum():,} individuals exited.")
    return df

df_eff = apply_migration_module(df_eff)


# Assumptions based on academic literature (e.g., Durán-Cabré et al., Zucman, Alstadsæter):
EVASION_RATE = 0.30           # 30% of taxable wealth evaded (undisclosed or offshore)
UNDERVALUE_RATE = 0.15         # 15% undervaluation of assets, esp. real estate
REGIONAL_REDUCTION = 0.33     # 33% lost due to regional exemptions (e.g., family businesses, Madrid)

# Total adjustment factor:
adjustment_factor = (1 - EVASION_RATE) * (1 - UNDERVALUE_RATE) * (1 - REGIONAL_REDUCTION)
def apply_adjustments(df):
    df = df.copy()
    df["adjusted_taxable_wealth"] = df["taxable_wealth_eroded"] * adjustment_factor
    df["adjusted_sim_tax"] = df["sim_tax"] * adjustment_factor
    df["adjusted_final_tax"] = df["final_tax"] * adjustment_factor
    df["adjusted_cap_relief"] = df["cap_relief"] * adjustment_factor

    print(f" Adjustments applied: {df['adjusted_final_tax'].sum():,.2f} EUR total tax.")
    return df

df_eff = apply_adjustments(df_eff)

# --- SUMMARY TABLE GENERATION ---
def generate_summary_table(df, weight_col="facine3"):
    revenue_collected = (df["final_tax"] * df[weight_col]).sum()
    revenue_without_cap = (df["sim_tax"] * df[weight_col]).sum()
    cap_relief = revenue_without_cap - revenue_collected

    revenue_after_migration = (df["final_tax"] * (~df["Migration_Exit"]) * df[weight_col]).sum()
    migration_loss = revenue_collected - revenue_after_migration

    erosion_loss = (df["taxable_wealth"] - df["taxable_wealth_eroded"]) * df[weight_col]
    erosion_total_loss = erosion_loss.sum()

    return pd.DataFrame({
        "Metric": [
            "Revenue Collected (with cap)",
            "Revenue Without Cap",
            "Cap Relief (Revenue Lost)",
            "Revenue After Migration",
            "Migration Loss",
            "Behavioral Erosion (Implicit Loss)",
        ],
        "EUR": [
            revenue_collected,
            revenue_without_cap,
            cap_relief,
            revenue_after_migration,
            migration_loss,
            erosion_total_loss,
        ]
    })

# --- TYPOLOGY IMPACT TABLE ---
def typology_impact_summary(df, weight_col="facine3"):
    return df.groupby("mismatch_type").apply(
        lambda g: pd.Series({
            "Population Share": g[weight_col].sum() / df[weight_col].sum(),
            "Avg Final Tax": np.average(g["final_tax"], weights=g[weight_col]),
            "Avg Sim Tax": np.average(g["sim_tax"], weights=g[weight_col]),
            "Cap Relief Share": (g["cap_relief"] > 1e-6).mean(),
            "Migration Rate": g["Migration_Exit"].mean(),
            "Total Revenue": (g["final_tax"] * g[weight_col]).sum()
        })
    ).reset_index()


summary_table = generate_summary_table(df_eff)
typology_table = typology_impact_summary(df_eff)
